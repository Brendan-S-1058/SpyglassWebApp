<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crow's Nest</title>
  <link rel="icon" type="image/x-icon" href="favico/favicon.ico">
  <link href="datastyle.css" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">
  <div class="container mx-auto p-4" id="table">
    <div id="title">
      <h1 class="text-3xl font-bold mb-4">Pick List Generator</h1>
    </div>
    <div class="mb-4 flex justify-between items-center">
      <button id="modePublic" class="On">Pull From Public</button>
      <button id="graph?" class="On">SPEED</button>
      <button id="oldGraphs" class="On">Old Graphs</button>
      <button id="sort" class="button">Generate List</button>
      <select id="sortMeth" name="sortMeth">
        <option value="aps">Avg points scored</option> 
        <option value="opr">OPR</option>
        <option value="dpropr">DPR by OPR</option>
        <option value="dpraps">DPR by APS</option>
        <outgroup label="Component OPR">
          <option value="l1c">L1 coral</option> 
          <option value="l2c">L2 coral</option>
          <option value="l3c">L3 coral</option>
          <option value="l4c">L4 coral</option>
          <option value="tcc">Total Coral Count</option> 
          <option value="tcs">Total Coral Score</option>
          <option value="tac">Total Algae Count</option>
          <option value="tgpc">Total Game Piece</option>
          <option value="acc">Auto Coral Count</option> 
          <option value="ams">Auto Mobility Score</option>
          <option value="taus">Total Auto Score</option>
          <option value="tts">Total Teleop Score</option>
          <option value="tecc">Teleop Coral Count</option>
          <option value="tas">Total Algae Score</option> 
          <option value="tna">Total Net Alage</option>
          <option value="tpa">Total Processor Alage</option>
        </outgroup>
      </select>
      <button id="explain" class="button">Explain</button>
    </div>
    <div class="overflow-auto border rounded-lg shadow bg-white">
      <table class="min-w-full table-fixed">
        <thead class="bg-gray-200 text-left">
          <tr>
            <th>
              <button id="Team" class="button">Team</button>
            </th>
            <th>              
              <button id="metaAverageScore" class="button">Meta Average Score</button>
            </th>
            <th>              
              <button id="averageScore" class="button">Average Score</button>
            </th>
            <th>
              <button id="metaMax" class="button">Meta Max</button>
            </th>
            <th>
              <button id="holdMax" class="button">Max</button>
            </th>
            <th>
              <button id="autoAvg" class="button">Auto Avg</button>
            </th>
            <th>
              <button id="teleAvg" class="button">Tele Avg</button>
            </th>
            <th>
              <button id="accuracy" class="button">Accuracy</button>
            </th>
            <th>
              <button id="averageAutoClimb" class="button">Average Auto Climb</button>
            </th>
            <th>
              <button id="averageTeleClimb" class="button">Average Tele Climb</button>
            </th>
            <th>
              <button id="averageAutoFuel" class="button">Average Auto Fuel</button>
            </th>
            <th>
              <button id="canBump" class="button">Can Bump</button>
            </th>
            <th>
              <button id="canTrench" class="button">Can Trench</button>
            </th>
          </tr>
        </thead>
        <tbody id="data-table-body">
        </tbody>
      </table>
      <div id="images"></div>
    </div>
  </div>
</body>
<script>
  let coprs = ['l1c', 'l2c', 'l3c', 'l4c', 'tcc', 'tcs', 'tac', 'tgpc', 'acc', 'ams', 'taus', 'tts', 'tecc', 'tas', 'tna', 'tpa']
  let oldGraphs = 1;
  let graphState = 1;
  let modeState = 1;
  let send = null;
  document.getElementById('modePublic').addEventListener("click", () => {
    modeState += 1;
    if (modeState > 2) {
      modeState = 0;
    }
    if (modeState == 0) {
      document.getElementById('modePublic').style.color = "#ff0000";
    } else if (modeState == 1) {
      document.getElementById('modePublic').style.color = "#00ff00";
    } else {
      document.getElementById('modePublic').style.color = "#0000ff";
    }
  });

  document.getElementById('oldGraphs').addEventListener("click", () => {
        oldGraphs *= -1;
    if (oldGraphs == -1) {
      document.getElementById('oldGraphs').style.color = "#ff0000";
    } else if (oldGraphs == 1) {
      document.getElementById('oldGraphs').style.color = "#00ff00";
    } 
  });

  document.getElementById('graph?').addEventListener("click", ()=> {
    graphState *= -1;
    if (graphState == -1) {
      document.getElementById('graph?').style.color = "#ff0000";
    } else if (graphState == 1) {
      document.getElementById('graph?').style.color = "#00ff00";
    } 
  });

  document.getElementById('sort').addEventListener("click", async () => {
    if (modeState == 0) {
      if (document.getElementById('sortMeth').value == 'aps'  || document.getElementById('sortMeth').value == 'dpraps') {
        send = [localStorage.getItem('team'), -1, JSON.parse(localStorage.getItem("qrCodes"))];
      } else {
        send = [localStorage.getItem('team'), JSON.parse(localStorage.getItem("qrCodes"))];
      }
    } else if (modeState == 1) {
      send = [localStorage.getItem('team'), 1];
    } else {
      send = [localStorage.getItem('team'), 2];
    }

    let data;

    if (graphState == -1) {
      if (document.getElementById('sortMeth').value == 'aps') {
        Graph(send);
        data = await Sort(send); 
      } else if (document.getElementById('sortMeth').value == 'opr') {
        OprGraph([localStorage.getItem('team') + '@'].concat(send));
        console.log("OPRING - 1");
        data = await opr(send);
      } else if (document.getElementById('sortMeth').value == 'dpropr') {
        OprGraph([localStorage.getItem('team') + '@'].concat(send));
        console.log("DPRING - 1");
        data = await dpro(send);
      } else if (document.getElementById('sortMeth').value == 'dpraps') {
        Graph(send);
        console.log("DPRING - 0");
        data = await dpra(send);
      } else if (coprs.includes(document.getElementById('sortMeth').value)) {
        OprGraph([localStorage.getItem('team') + '@'].concat(send));
        console.log ('COPRSSSSS WOOOOOOOOO')
        data = await copr([document.getElementById('sortMeth').value + '@'].concat(send));
      }
    } else if (graphState == 1) {
      if (document.getElementById('sortMeth').value == 'aps') {
        data = await Sort(send);
      } else if (document.getElementById('sortMeth').value == 'opr'){
        data = await opr(send);
        console.log('OPRING - 2');
      } else if (document.getElementById('sortMeth').value == 'dpropr') {
        console.log("DPRING - 2");
        data = await dpro(send);
      } else if (document.getElementById('sortMeth').value == 'dpraps') {
        console.log("DPRING - 3");
        data = await dpra(send);
      } else if (coprs.includes(document.getElementById('sortMeth').value)) {
        console.log ('COPRSSSSS WOOOOOOOOO')
        data = await copr([document.getElementById('sortMeth').value + '@'].concat(send));
      }
    }

    console.log('data: ' + data);

    const table = document.getElementById("data-table-body");
    table.innerHTML = '';
    
    data.forEach(line => {
      if (document.getElementById('sortMeth').value == 'aps') {
        createRow(line);
      } else if (document.getElementById('sortMeth').value == 'opr' || coprs.includes(document.getElementById('sortMeth').value)) {
        createRowOpr(line);
      } else if (document.getElementById('sortMeth').value == 'dpropr' || document.getElementById('sortMeth').value == 'dpraps') {
        createRowOpr(line);
      }
    });
  });

  async function copr(input) {
    const res = await fetch ("/oprsort", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(input),
    });

    console.log(res);

    if (!res.ok){
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }
    return (json);
  }

  async function opr(input) {
    input = ['opr@'].concat(input)
    const res = await fetch ("/oprsort", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(input),
    });

    console.log(res);

    if (!res.ok){
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }
    return (json);
  }

async function dprSort(input) {
      const res = await fetch ("/dprsort", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify([input]),
    });

    console.log(res);

    if (!res.ok){
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }
    return (json);
  }

  async function dpro(input) {
    let avgs = '';
    allData = await opr(input);
    allData.forEach(line => {
      console.log('line: ' + line);
      separate = line.split(",").map(s => s.trim().replace(/[\["\/]/g, ""));
      if (separate[0] != "") {
        if (avgs.length>0) {
          avgs = avgs + '/' + separate[0] + ',' + separate[1];
        } else {
          avgs = separate[0] + ',' + separate[1]
        }
      };
    });
    console.log('avgs: ' + avgs);
    send = input + '₯' + avgs;

    console.log('send: ' + send);
    console.log('JSON.stringify(send): ' + JSON.stringify(send));

    return (await dprSort(send));
  }
  
async function dpra(input) {
    let avgs = '';
    allData = await Sort(input);
    allData.forEach(line => {
      separate = line.split(",").map(s => s.trim().replace(/[\["\/]/g, ""));
      if (separate[0] != "") {
        if (avgs.length>0) {
          avgs = avgs + '/' + separate[0] + ',' + separate[1];
        } else {
          avgs = separate[0] + ',' + separate[1]
        }
      };
    });
    console.log('avgs: ' + avgs);

    send = input + '₯' + avgs;

    return (await dprSort(send));
  }

  function createRow(csv){
        const fields = csv.split(",").map(s => s.trim().replace(/[\["\/]/g, ""));
        if (fields.length !== 13) {
          console.error("createRow: expected 13 comma‑separated values, got", fields.length);
          return;
        }
        const [
          team, metAvg, trueAvg, metMax, trueMax, autoAvg, teleAvg, Acc, avgAClimb, avgTClimb, avgAFuel, canBump, canTrench
        ] = fields;

        const table = document.getElementById("data-table-body");
        const newRow = document.createElement('tr');
        newRow.contentEditable = "false";
        newRow.innerHTML = `
            <td class="p-2 border">`+team+`</td>
            <td class="p-2 border">`+metAvg+`</td>
            <td class="p-2 border">`+trueAvg+`</td>
            <td class="p-2 border">`+metMax+`</td>
            <td class="p-2 border">`+trueMax+`</td>
            <td class="p-2 border">`+autoAvg+`</td>
            <td class="p-2 border">`+teleAvg+`</td>
            <td class="p-2 border">`+Acc+`</td>
            <td class="p-2 border">`+avgAClimb+`</td>
            <td class="p-2 border">`+avgTClimb+`</td>
            <td class="p-2 border">`+avgAFuel+`</td>
            <td class="p-2 border">`+canBump+`</td>
            <td class="p-2 border">`+canTrench+`</td>`
            table.appendChild(newRow);
            };
  
  function createRowOpr(csv){
        const fields = csv.split(",").map(s => s.trim().replace(/[\["\/]/g, ""));
        if (fields.length !== 2) {
          console.error("createRow: expected 2 comma‑separated values, got", fields.length);
          return;
        }
        const [
          team, opr
        ] = fields;

        const table = document.getElementById("data-table-body");
        const newRow = document.createElement('tr');
        newRow.contentEditable = "false";
        newRow.innerHTML = `
            <td class="p-2 border">`+team+`</td>
            <td class="p-2 border">`+opr+`</td>`

        table.appendChild(newRow);
            };

  async function Graph(State) {

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }

    const res = await fetch ("/PLSort", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(State),
    });

    console.log(res);

    if (!res.ok){
      alert ("You are not signed in as a team, that's bad (I probably redeployed). That means nothing will work right until you set your team (home page, change team button)");
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    try {
      const graph = document.createElement('img');
      graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
      graph.width = 600;
      graph.height = 400;

      const division = document.getElementById("images");
      division.innerHTML='';

      division.appendChild(graph);

    } catch (e) {
      console.error("Yikes (The graph didn't work).");
      console.error(e);
      return;
    }

    return (json);
  }

  async function OprGraph(State) {

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }

    const res = await fetch ("/OPRgraph", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(State),
    });

    console.log(res);

    if (!res.ok){
      alert ("You are not signed in as a team, that's bad (I probably redeployed). That means nothing will work right until you set your team (home page, change team button)");
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    try {
      const graph = document.createElement('img');
      graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
      graph.width = 600;
      graph.height = 400;

      const division = document.getElementById("images");
      division.innerHTML='';

      division.appendChild(graph);

    } catch (e) {
      console.error("Yikes (The graph didn't work).");
      console.error(e);
      return;
    }

    return (json);
  }

  async function Sort(State) {
    const res = await fetch ("/PLSort2", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(State),
    });

    console.log(res);

    if (!res.ok){
      throw new Error("HTTP error " + res.status);
    }

    const json = await res.json();

    if (oldGraphs == 1){
      try {
        const graph = document.createElement('img');
        graph.src = "data/Teams/" + localStorage.getItem('team') + "/" + localStorage.getItem('team') + "Graphs/AVT.png";
        graph.width = 600;
        graph.height = 400;

        const division = document.getElementById("images");
        division.innerHTML='';

        division.appendChild(graph);

      } catch (e) {
        console.error("Yikes (The graph didn't work).");
        console.error(e);
        return;
      }
    }

    return (json);
  }


  document.getElementById('Team').addEventListener('click', ()=> {

  });

  document.getElementById('metaAverageScore').addEventListener('click', ()=> {
    table = document.getElementById('data-table-body');

    const rows = Array.from(table.rows);
    console.log (rows);

  });

  document.getElementById('averageScore').addEventListener('click', ()=> {

  });

  document.getElementById('metaMax').addEventListener('click', ()=> {

  });

  document.getElementById('holdMax').addEventListener('click', ()=> {

  });

  document.getElementById('autoAvg').addEventListener('click', ()=> {

  });

  document.getElementById('teleAvg').addEventListener('click', ()=> {

  });

  document.getElementById('accuracy').addEventListener('click', ()=> {

  });

  document.getElementById('averageAutoClimb').addEventListener('click', ()=> {

  });

  document.getElementById('averageTeleClimb').addEventListener('click', ()=> {

  });

  document.getElementById('averageAutoFuel').addEventListener('click', ()=> {

  });

  document.getElementById('canBump').addEventListener('click', ()=> {

  });

  document.getElementById('canTrench').addEventListener('click', ()=> {

  });

  document.getElementById('explain').addEventListener('click', ()=>{
    alert ("Pull From Public: a toggleable mode which dictates where the data is coming from - green means from the communal public file, blue means from your TEAM's personal data, not just your local, red means just the local data stored on this device.\n\nSPEED: Behaves very similarly to the aforementioned Pull From Public, except instead of changing where the data comes from, it makes the process faster if it is green (on) by not generating a graph, and slower if it is red (off) by taking the time to make a graph\n\nOld Graphs: Old Grpahs will, if enabled (green), import the most recent graph generated either before making a new one, or, if SPEED is enabled, just import the last graph. This can be dangerous because the graph could not represent recent data, especially if SPEED is enabled.\n\nGenerate List: generates a list of teams sorted by the selected method in the dropdown box using information from the selected data method.\n\nDropdown: the dropdown box allows you to pick the sorting method for the picklist, generally I'd suggest APS (average points scored) because that's what this site was made for, but OPR is pretty close (OPR is generated locally in case TBA is down for whatever reason, if you want OPR, I suggest going there, otherwise this will be very close), DPR by OPR is a defensive metric which measures the estimated negative impact on the opposing alliances final score using the same linear algebra as OPR and OPR as the method for predicting a given alliance's score, and lastly, DPR by APS is the same as by OPR except it uses APS to predict an alliance's score.")
});
</script>
</html>